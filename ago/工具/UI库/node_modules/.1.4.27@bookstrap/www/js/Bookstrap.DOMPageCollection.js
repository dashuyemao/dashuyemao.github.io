define([
  'underscore',
  'Bookstrap.DOMPage'
  ],
  function(_, DOMPage) {

    var DOMPageCollection = function(options) {
      this.$pagesContainer = options.$pagesContainer;
      this.pages = options.pages;
      this.domPages = [];
      this.current = null;
    };

    DOMPageCollection.prototype = {

      init: function() {
        var self = this;
        this.$pagesContainer.children().each(function(index) {
          var domPage = new DOMPage(this, index-1);
          self.domPages.push(domPage);
          bookstrap.emit('pagecreated', domPage);
        });
        if (this.domPages.length !== 3) {
          throw 'Invalid DOM structure. 3 child nodes expected in pagesContainer';
        }
        this.current = this.domPages[1];

        bookstrap.on('pagecache', _.bind(this.navigationCached, this));
      },

      setCurrentPage: function(page) {
        if (this.current && this.current.page === page) {
          console.warn('Attempted to set the current page again');
          return this.current;
        }
        var domPage = this.findNodeByPageLoaded(page);
        if (! domPage) {
          domPage = this.current;
        }
        domPage.page = page;
        return this.setCurrentDOMPage(domPage);
      },

      setCurrentDOMPage: function(domPage) {
        if (this.current.pageLoaded !== undefined) {
          bookstrap.emit('pageunload', this.current);
        }
        this.current = domPage;
        this.current.position = DOMPage.POSITION_CENTER;
        var self = this;
        bookstrap.emit('beforepageload', domPage);
        this.current.load(function() {
          self.current.bindEvents();
          document.title = domPage.page.title + ' - ' + bookstrap.title;

          bookstrap.emit('pageload', self.current);
        });
        this.updateCache();
        return domPage;
      },

      setCurrentByIndex: function(index) {
        if (index > this.domPages.length) {
          console.warn('Invalid index');
          return;
        }
        var domPage = this.domPages[index];
        if (! domPage) {
          console.warn('Could not find DOM node when setting current by index');
          return;
        }
        return this.setCurrentDOMPage(domPage);
      },

      findNode: function(el) {
        return _.find(this.domPages, function(domPage) {
          return domPage.el === el;
        });
      },

      findNodeByPageLoaded: function(page, availableDOMPages) {
        var searchList = availableDOMPages || this.domPages;
        return _.find(searchList, function(domPage) {
          return domPage.pageLoaded === page;
        });
      },

      updateCache: function() {
        var currentPageIndex = this.pages.indexOf(this.current.page),
            rightPage = this.pages.getNext(currentPageIndex),
            leftPage = this.pages.getPrevious(currentPageIndex),
            optimalDOMNodes = this.findOptimalDOMNodes(leftPage, rightPage),
            rightDOMPage = optimalDOMNodes.right,
            leftDOMPage = optimalDOMNodes.left;
        
        rightDOMPage.page = rightPage;
        rightDOMPage.position = DOMPage.POSITION_RIGHT;
        leftDOMPage.page = leftPage;
        leftDOMPage.position = DOMPage.POSITION_LEFT;

        if (! leftDOMPage.isLeft()) {
          leftDOMPage.updatePosition(DOMPage.POSITION_LEFT);
        }
        if (! rightDOMPage.isRight()) {
          rightDOMPage.updatePosition(DOMPage.POSITION_RIGHT);
        }

        if (leftDOMPage.page) {
          leftDOMPage.load();
        } else {
          // We are on the first page
        }
        if (rightDOMPage.page) {
          rightDOMPage.load();
        } else {
          // We are on the last page
        }
        this.navigationCached();
      },

      findOptimalDOMNodes: function(pageLeft, pageRight) {
        var availableDOMPages = this.getCached(),
            domPageLeft = this.findNodeByPageLoaded(pageLeft, availableDOMPages),
            domPageRight = null;

        // Match by content that is already loaded in the DOM
        if (domPageLeft) {
          availableDOMPages.splice(availableDOMPages.indexOf(domPageLeft), 1);
          domPageRight = availableDOMPages.pop();
        } else {
          domPageRight = this.findNodeByPageLoaded(pageRight, availableDOMPages);
          if (domPageRight) {
            availableDOMPages.splice(availableDOMPages.indexOf(domPageRight), 1);
            domPageLeft = availableDOMPages.pop();
          }
        }
        // Match by DOM nodes that are already in the right position
        if (! domPageRight) {
          domPageLeft = availableDOMPages[0];
          domPageRight = availableDOMPages[1];
        }
        return {
          left: domPageLeft,
          right: domPageRight
        };
      },

      moveLeft: function(domPage) {
        // Update this.domPages to reflect the DOM
        var domPageIndex = this.indexOf(domPage),
            currentDOMIndex = this.indexOf(this.current);
        if (domPageIndex > currentDOMIndex) {
          domPage.moveLeft(this.current);
          var removedElements = this.domPages.splice(domPageIndex, 1);
          if (currentDOMIndex > 0)
            currentDOMIndex--;
          // Insert before current
          this.domPages.splice(currentDOMIndex, 0, removedElements[0]);
        }
      },

      moveRight: function(domPage) {
        // Update this.domPages to reflect the DOM
        var domPageIndex = this.indexOf(domPage),
            currentDOMIndex = this.indexOf(this.current);
        if (domPageIndex < currentDOMIndex) {
          domPage.moveRight(this.current);
          var removedElements = this.domPages.splice(domPageIndex, 1);
          currentDOMIndex--;
          // Insert after current
          this.domPages.splice(currentDOMIndex + 1, 0, removedElements[0]);
        }
      },



      getLeftDOMPage: function() {
        return this.findByPosition(DOMPage.POSITION_LEFT);
      },

      getCenterDOMPage: function() {
        return this.findByPosition(DOMPage.POSITION_CENTER);
      },

      getRightDOMPage: function() {
        return this.findByPosition(DOMPage.POSITION_RIGHT);
      },

      findByPosition: function(position) {
        return _.find(this.domPages, function(domPage) {
          return domPage.position === position;
        });
      },

      resize: function(width, height) {
        this.$pagesContainer
          .width(width * this.domPages.length)
          .height(height);
        this.$pagesContainer.children()
          .width(width)
          .height(height);
      },

      getCached: function() {
        return _.filter(this.domPages, function(domPage) {
          return domPage !== this.current;
        }, this);
      },

      navigationCached: function() {
        var allCached = _.every(this.domPages, function(domPage) {
          return domPage.isCacheReady();
        });
        if (allCached) {
          var cachedPages = this.getCached();
          bookstrap.emit('navigationcached', this.current, cachedPages);
        }
      },

      indexOf: function(domPage) {
        return this.domPages.indexOf(domPage);
      },

      forEach: function(fn) {
        return this.domPages.forEach(fn);
      },

      get: function(index) {
        return this.domPages[index];
      }

    };

    DOMPageCollection.prototype.getLength = function() {
      return this.domPages.length;
    };
    // DOMPageCollection.prototype.__defineGetter__("length", function() {
    //   return this.domPages.length;
    // });

    return DOMPageCollection;
  }
);