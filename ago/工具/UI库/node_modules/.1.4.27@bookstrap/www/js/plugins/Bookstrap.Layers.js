(function(){
	define('plugins/Bookstrap.Layers', [
		'underscore',
		'imagesloaded'
		],
		function(_, imagesLoaded) {
			var LayerGroup = function(bookstrap, el){
				_.bindAll(this);
				this.bookstrap = bookstrap;
				this.$el = $(el);
				this.init();
			};

			// shorthand
			var l = LayerGroup.prototype;

			// Base functions

			l.init = function(){
				var self = this;

				// caching elements
				this.$nav = this.$el.find('.book-nav');
				this.$navLi = this.$nav.find('li');
				this.$wrap = $('<div class="book-layers-wrap">');
				this.$slider = $('<div class="book-layers-slider">');
				this.$layers = this.$el.find('.book-layer').wrapAll(this.$slider);
				this.$slider.wrap(this.$wrap);
				this.$images = this.$layers.find('img');
				this.$animations = this.$layers.find('.book-animation');

				// determine options
				var initial = this.$layers.index(this.$layers.find('.book-layer-active'));
				this.options = {
					method: this.$el.attr('data-method') || (this.$el.attr('data-swipe') === 'false' ? 'none' : 'swipe'),
					transition: this.$el.attr('data-transition') || 'none',
					duration: parseInt(this.$el.attr('data-duration'), 10) || 500,
					easing: this.$el.attr('data-easing') || 'cubic-bezier(0.645, 0.045, 0.355, 1.000)',
					initialLayer: (initial === -1 ? 0 : initial)
				};

				// dont do anything if only one layer
				if(this.$layers.length <= 1){
					return;
				}

				// setup slider for slide transition
				this.slideWidth = this.$wrap.width();
				if(this.options.transition === 'slide'){
					this.slideWidthPerc = 100 / this.$layers.length;
					this.$slider.css('width', (100 * this.$layers.length) + '%');
					this.$layers.css({
						'width': this.slideWidthPerc + '%'
					});
				}

				// if no transition, use fade with duration = 0
				if(this.options.transition === 'none'){
					this.options.duration = 0;
				}

				// determine height
				if(this.options.transition !== 'slide'){
					var images = this.$images.not('.book-image-placeholder'); // consider this.$images.not('[src]')
					if (images.length > 0) {
						imagesLoaded(images, function() {
							self.resetHeight();
						});
					}else{
						this.resetHeight();
					}
				}

				// reset animations
				this.resetAnimationsInLayers();

				this.$el.addClass('book-layers-ready');

				// setup hammer instance
				this.hammer = this.$wrap.hammer();

				this.move(this.options.initialLayer);
			};

			l.bindEvents = function(){
				if(this.options.method === 'swipe'){
					this.hammer
						.on('touchstart.layers', this.preventPageSwipe)
						.on('dragend.layers dragleft.layers dragright.layers swipeleft.layers swiperight.layers', this.handleHammer);
				}else if(this.options.method === 'tap'){
					this.hammer
						.on('tap.layers', this.determineDirection);
				}
				this.$nav.on('click.layers', 'a', this.navHandler);
				this.bookstrap.on('resize', this.onResize);
			};

			l.unbindEvents = function(){
				this.hammer.off('.layers');
				this.$nav.off('.layers');
				this.bookstrap.removeListener('resize', this.onResize);
			};

			l.destroy = function(){
				this.move(0);
				this.unbindEvents();
				//this.$layers.unwrap().attr('style', '');
				//this.$el.removeClass('book-layers-ready');
			};

			
			// helper functions
			
			l.isSlide = function(index){
				return this.$layers.eq(index).length > 0;
			};

			l.isFirst = function(index){
				index = typeof index === 'undefined' ? this.activeLayerIndex : index;
				return index === 0;
			};

			l.isLast = function(index){
				index = typeof index === 'undefined' ? this.activeLayerIndex : index;
				return index === this.$layers.length - 1;
			};

			l.getPreviousIndex = function(){
				if (this.isFirst()){
					if(this.options.transition === 'slide'){
						return this.activeLayerIndex;
					}
					return this.$layers.length - 1;
				}
				return this.activeLayerIndex - 1;
			};

			l.getNextIndex = function(){
				if (this.isLast()){
					if(this.options.transition === 'slide'){
						return this.activeLayerIndex;
					}
					return 0;
				}
				return this.activeLayerIndex + 1;
			};

			l.shouldResist = function(direction){
				return (this.isFirst() && direction === Hammer.DIRECTION_RIGHT || this.isLast() && direction === Hammer.DIRECTION_LEFT);
			};


			// Moving
			
			l.moveLeft = function(){
				var index = this.getPreviousIndex();
				if(index !== this.activeLayerIndex){
					this.move(index);
				}
			};

			l.moveRight = function(){
				var index = this.getNextIndex();
				if(index !== this.activeLayerIndex){
					this.move(index);
				}
			};

			l.move = function(index){
				var val;

				if(!this.isSlide(index) || this.animating){
					return;
				}
				
				// set active class
				var oldLayer = this.$layers.eq(this.activeLayerIndex).removeClass('book-layer-active');
				this.$navLi.eq(this.activeLayerIndex).removeClass('book-active');
				this.activeLayerIndex = index;
				var newLayer = this.$layers.eq(this.activeLayerIndex).addClass('book-layer-active');
				this.$navLi.eq(this.activeLayerIndex).addClass('book-active');

				// load placeholder images
				this.loadPlaceholders();

				// do the animation animation
				if(this.options.transition === 'slide'){
					val = this.activeLayerIndex * (this.slideWidth) * -1;
					this.animateSlide(val);
				}else{
					this.animateFade(newLayer, oldLayer);
				}
			};

			// Internal Animation

			l.animateSlide = function(val, duration) {
				if(typeof duration === 'undefined'){
					duration = this.options.duration;
				}

				this.beforeAnimate(duration);

				// animate
				if(duration > 0){
					this.$slider.animate({
						'translate3d': Math.round(val) + 'px,0,0'
					}, duration, this.options.easing, _.bind(this.afterAnimate, this, this.$slider));
				}else{
					this.$slider.css($.fx.cssPrefix + 'transform', 'translate3d(' + Math.round(val) + 'px,0,0)');
				}
			};

			l.animateFade = function(newLayer, oldLayer, duration){
				// if first show or same element
				if(oldLayer.length === 0 || oldLayer.get(0) === newLayer.get(0)){
					return;
				}

				if(typeof duration === 'undefined'){
					duration = this.options.duration;
				}

				this.beforeAnimate(duration);
				this.resetAnimationsInLayers();

				oldLayer.addClass('book-layer-while-animating');

				oldLayer.fadeOut(duration, _.bind(this.afterAnimate, this, oldLayer));
				newLayer.fadeIn(duration, _.bind(this.afterAnimate, this, newLayer));
			};

			l.beforeAnimate = function(dur){
				if (dur > 0) {
					this.animating = true;
					this.$el.addClass('book-layers-animating');
				}
			};

			l.afterAnimate = function(el){
				el.removeClass('book-layer-while-animating');
				this.animating = false;
				this.$el.removeClass('book-layers-animating');
				
				if(this.options.transition === 'slide'){
					this.resetAnimationsInLayers();
					this.startAnimationsInLayer(this.$layers.eq(this.activeLayerIndex));
				}else if(el.hasClass('book-layer-active')){
					this.startAnimationsInLayer(el);
				}
			};


			// Bookstrap.Animations inside Layers
			
			l.resetAnimationsInLayers = function() {
				this.$animations.each(function(i, el) {
					el.style.webkitAnimation = 'none';
					setTimeout(function() {
						el.style.webkitAnimation = '';
					}, 10);
				});
			};

			l.startAnimationsInLayer = function(layer) {
				var $animations = layer.find('.book-animation');
				$animations.each(function(i, el) {
					el.style.webkitAnimationPlayState = 'running';
				});
			};


			// placeholder handling
			
			l.loadPlaceholders = function(){
				var prevImages = this.$layers.eq(this.getPreviousIndex());
				var nextImages = this.$layers.eq(this.getNextIndex());
				var images = prevImages.add(nextImages).find('.book-image-placeholder'); // consider this.$images.not('[src]')
				
				images.each(function(index, item){
					var src = images.eq(index).attr('data-src');
					if(src && src.length > 0){
						images.eq(index)
							.css('padding-bottom', '')
							.removeClass('book-image-placeholder')
							.attr('src', src)
							.removeAttr('data-src');
					}
				});
			};

			// height determination
			
			l.resetHeight = function(){
				var self = this;

				// reset height before calculating
				//this.$slider.css('height', '');

				// prevent scrollbars (should only be problem in desktop)
				this.$wrap.css('overflow', 'hidden');

				// show all elements
				this.$layers
					.css({'display': 'block', 'visibility': 'hidden'})
					.eq(this.activeLayerIndex || this.options.initialLayer)
					.css({'visibility': ''});

				// Wait for repaint
				// Unfortunately we have no reliable way of telling when the browser has finished repainting
				setTimeout(function() {

					// get tallest height
					var maxHeight = _.reduce(self.$layers, function(memo, layer){
						var height = $(layer).height();
						if(height > memo){
							return height;
						}
						return memo;
					}, 0);

					// set height
					self.$slider.css('height', maxHeight);
					self.$layers.css({'display': '','visibility':''});
					self.$wrap.css('overflow', '');
				}, 15);
			};

			// Eventhandlers

			l.handleHammer = function(e){
				e.gesture.preventDefault(); //todo: test whether this causes problems
				
				switch(e.type){
					case 'swiperight':
						this.moveLeft();
						this.swiping = true;
					break;

					case 'swipeleft':
						this.moveRight();
						this.swiping = true;
					break;

					case 'dragleft':
					case 'dragright':
						// if first layer and dragging left OR last layer and dragging right
						var resistValue = this.shouldResist(e.gesture.direction) ? (Math.abs(e.gesture.deltaX) * 1.5 /  this.slideWidth + 1) : 1;
						var deltaX = e.gesture.deltaX / resistValue;

						// translate immediately 1-to-1
						if(!this.animating && this.options.transition === 'slide'){
							this.animateSlide((deltaX - this.activeLayerIndex * this.slideWidth), 0);
						}
					break;

					case 'dragend':
						// if sliding transition dont allow swipe beyond boundaries, otherwise if swiped past 50% of layer
						if ((!this.shouldResist(e.gesture.direction) || this.options.transition !== 'slide') &&
								Math.abs(e.gesture.deltaX) > this.slideWidth / 2 && !this.swiping) {
							// more then 50% moved, navigate
							if (e.gesture.direction == Hammer.DIRECTION_RIGHT) {
								this.moveLeft();
							}else{
								this.moveRight();
							}
						}else{
							this.move(this.activeLayerIndex);
						}
						this.swiping = false;
					break;
				}
			};

			l.determineDirection = function(e){
				if($(e.target).is('a')){
					return;
				}
				
				// was the tap on left or right half of element?
				if((e.gesture.center.pageX - this.$wrap.offset().left) > this.slideWidth / 2){
					this.moveRight();
				}else{
					this.moveLeft();
				}
			};

			l.navHandler = function(e){
				e.preventDefault();
				e.stopPropagation();
				this.move(parseInt($(e.currentTarget).attr('data-index'), 10) || 0);
			};

			l.preventPageSwipe = function(e){
				e.bookstrapTouchStartListener = this;
			};

			l.onResize = function(e){
				var self = this;

				// reset height
				if(this.options.transition !== 'slide'){
					this.resetHeight();
				}

				// Wait for repaint
				setTimeout(function() {
					self.slideWidth = self.$wrap.width();

					// if size changes, move back into position
					if(self.options.transition === 'slide'){
						self.animateSlide((self.activeLayerIndex * (self.slideWidth) * -1), 0);
					}
				}, 15);
			};

			// Manager

			var LayersManager = function(bookstrap){
				_.bindAll(this);
				this.bookstrap = bookstrap;
				this.layerGroups = [];
				bookstrap.on('pagecache', this.setup);
				bookstrap.on('pageload', this.bindEvents);
				bookstrap.on('pageunload', this.unbindEvents);
			};

			LayersManager.prototype = {

				setup: function(domPage) {
					var self = this;
					this.layerGroups[domPage.page.href] = [];
					domPage.$el.find('.book-layers').each(function() {
						self.layerGroups[domPage.page.href].push(new LayerGroup(self.bookstrap, this));
					});
				},

				bindEvents: function(domPage){
					var self = this;
					_.each(this.layerGroups[domPage.page.href], function(layerGroup){
						layerGroup.bindEvents();
					});
				},

				unbindEvents: function(domPage){
					_.each(this.layerGroups[domPage.page.href], function(layerGroup){
						layerGroup.destroy();
					});
				}

			};

			return LayersManager;

		});
}());