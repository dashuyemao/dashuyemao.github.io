/*global bookstrap: false */
define([
  'underscore'
  ],
  function(_, ImagesLoaded) {

    var SCROLL_END_EVENT = ("ontouchmove" in document) ? 'scroll' : 'scrollend';
    var SCROLL_EVENT = ("ontouchmove" in document) ? 'touchmove' : 'scroll';

    var AnimationRegion = function(el, startY, endY) {
      this.el = el;
      this.$el = $(el);
      this.startY = startY;
      this.endY = endY;
    };

    AnimationRegion.prototype.playAnimation = function() {
      // don't start if it's in a non-active layer
      if ((this.$el.closest('.book-layer').length && this.$el.closest('.book-layer-active').length == 0))
        return; 
      
      this.el.style.webkitAnimationPlayState = 'running';
    };

    AnimationRegion.prototype.resetAnimation = function() {
      /*
      HACK:
      There is no proper way to restart an animation in JavaScript.
      We do it here by cloning the element and replacing it.
      More details here: http://css-tricks.com/restart-css-animation/
      */
      var $el     = $(this.el);
      var clone   = this.el.cloneNode(true);
      var $clone  = $(clone);

      clone.style.webkitAnimationPlayState = 'paused';

      // Store frame dimensions to preserve layout when image gets reloaded.
      $clone.width($el.width()).height($el.height());

      // Remove width and height when image is ready
      $clone.find('img').one('load', function(){
        $(this)
          .parent()
          .css({
            width:  '',
            height: ''
          });
      });

      this.el.parentNode.replaceChild(clone, this.el);
      this.el = clone;
    };

    var Animations = function() {
      _.bindAll(this);

      this.page = null;
      this.$page = null;
      this.$pageScrollContainer = null;
      this.previousTime = null;
      this.previousPageScrollY = null;
      this.previouslyActiveRegions = [];

      bookstrap.on('pageimagesload', this.onPageImagesLoad);
      bookstrap.on('pageunload', this.onPageUnload);
      bookstrap.on('pagecache', this.clearAnimationRegionsCache);
    };

    Animations.prototype.onPageImagesLoad = function(page) {
      this.onPageLoad(page);
      this.cacheAnimationRegions();
      this.updateAnimationForScrollPosition(this.$page.scrollTop());
    };

    Animations.prototype.onPageLoad = function(page) {
      this.page = page;
      this.$page = page.$el;
      // When this plugin is run on a normal webpage, $scrollContainer will be the page document
      this.$pageScrollContainer = page.$scrollContainer || page.$el;

      this.bindEvents();
    };

    Animations.prototype.onPageUnload = function() {
      this.unbindEvents();
    };

    Animations.prototype.bindEvents = function() {
      this.$pageScrollContainer.on(SCROLL_EVENT, this.onPageScroll);
      if (! bookstrap.hasTouchSupport)
        this.bindScrollEndPolyfill();
      this.$pageScrollContainer.on(SCROLL_END_EVENT, this.onPageScrollEnd);
    };

    Animations.prototype.unbindEvents = function() {
      this.$pageScrollContainer.off(SCROLL_EVENT, this.onPageScroll);
      this.$pageScrollContainer.off(SCROLL_END_EVENT, this.onPageScrollEnd);
      this.unbindScrollEndPolyfill();
    };

    Animations.prototype.bindScrollEndPolyfill = function() {
      this.scrollEndTimeout = null;
      var self = this;
      this.scrollEndEventHandler = function() {
        if (self.scrollEndTimeout)
          clearTimeout(self.scrollEndTimeout);
        self.scrollEndTimeout = setTimeout(function() {
          self.$pageScrollContainer.trigger('scrollend');
        }, 300);
      };
      this.$pageScrollContainer.on('scroll', this.scrollEndEventHandler);
    };

    Animations.prototype.unbindScrollEndPolyfill = function() {
      this.$pageScrollContainer.off('scroll', this.scrollEndEventHandler);
    };

    Animations.prototype.onPageScroll = function() {
      var pageScrollY = this.$page.scrollTop();
      var scrollTime = (new Date().getTime());

      if (this.previousPageScrollY) {
        var distance = Math.abs(pageScrollY - this.previousPageScrollY);
        var time = scrollTime - this.previousTime;
        var speed = distance / time;
        var isSlowScroll = speed < 0.75;
        if (isSlowScroll)
          this.updateAnimationForScrollPosition(pageScrollY);
      }
      this.previousPageScrollY = pageScrollY;
      this.previousTime = scrollTime;
    };

    Animations.prototype.onPageScrollEnd = function() {
      var pageScrollY = this.$page.scrollTop();
      this.updateAnimationForScrollPosition(pageScrollY);
    };

    Animations.prototype.updateAnimationForScrollPosition = function(pageScrollY) {
      var activeRegions = this.getActiveRegions(pageScrollY, pageScrollY + document.documentElement.clientHeight);
      var newlyActive = _.difference(activeRegions, this.previouslyActiveRegions);
      var newlyHidden = _.difference(this.previouslyActiveRegions, activeRegions);

      _.invoke(newlyActive, 'playAnimation');
      _.invoke(newlyHidden, 'resetAnimation');

      this.previouslyActiveRegions = activeRegions;
    };

    /*
    Get the animation regions that are currently on screen
     */
    Animations.prototype.getActiveRegions = function(startY, endY) {
      return _.filter(this.page.animationRegions, function(region) {
        return (startY <= region.endY && endY >= region.startY);
      });
    };

    Animations.prototype.cacheAnimationRegions = function() {
      if (! this.page.animationRegions) {
        this.page.animationRegions = [];
        var self = this;
        this.$page.find('.book-animation').each(function(i, el) {
          self.addAnimationRegion(el);

          // hack to prevent flickering 
          // has to be set on parent too and that can't be done in CSS
          el.parentNode.style.webkitBackfaceVisibility = 'hidden';
        });
      }

      //this.showAnimationRegions(this.$page);
    };

    Animations.prototype.clearAnimationRegionsCache = function(page) {
      delete page.animationRegions;
    };

    /*
    Show animation regions for debugging purposes
     */
    Animations.prototype.showAnimationRegions = function($container) {
      $('.animation-region').remove();
      this.page.animationRegions.forEach(function(region) {
        var position = 'top: ' + region.startY + 'px; height: ' + (region.endY-region.startY) + 'px';
        $container.append('<div class="animation-region" style="' + position + '; z-index:1000; width: 100%; position: absolute; background-color: rgba(255, 0, 0, 0.5); opacity: 0.5; -webkit-backface-visibility: hidden; -webkit-perspective: 1000;" />');
      });
    };

    Animations.prototype.addAnimationRegion = function(el) {
      var pos = Animations.getTriggerRegion(el);
      this.page.animationRegions.push(new AnimationRegion(el, pos.startY, pos.endY));
    };

    /*
    Sometimes the height of the element is 0 if an animation begins with a height of 0
    If this is the case, calculate the height based upon previous and next elements in the DOM
     */
    Animations.getTriggerRegion =function(el) {
      var height = $(el).height(),
          offset = $(el).offset(),
          name = $(el).css('-webkit-animation-name');

      if (offset.top < 0) {
        // dropin animation has start offset of -2000px
        offset.top = offset.top + 2000;
      }
      if (height === 0) {
        var prev = $(el).prev(),
            next = $(el).next(),
            offset = prev.offset();
        if (prev.length === 1 && next.length === 1) {
          offset.top += offset.height;
          height = next.offset().top - offset.top;
        } else {
          // Fallback to parent
          offset = $(el).parent().offset();
          height = offset.height;
        }
      }
      return {startY: offset.top, endY: offset.top + height};
    };

    return Animations;
});