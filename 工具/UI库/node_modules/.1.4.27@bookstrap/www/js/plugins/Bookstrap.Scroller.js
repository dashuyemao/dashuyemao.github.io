/* global bookstrap: false */
define([
  'underscore',
  'lib/events'
  ],
  function(_, EventEmitter) {
    var lastTime = 0;

    var requestAnimationFrame = window.requestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };

    var MAX_ANIMATION_TIME = 300;

    var BookstrapScroller = function(domPage, options) {
      this.domPage = domPage;
      this.canMoveNext = false;
      this.canMovePrevious = false;

      this._snapBoundary = options.snapBoundary;
      this._scrollResponseBoundary = options.scrollResponseBoundary;
      this._animationDuration = options.animationDuration;

      this._scrollTouchId = null; // track the touch that is moving the page
      this._width = options.width;
      this._offset = this._width * domPage.position;
      this._startOffset = this._offset;
      this._hasMoveStarted = false;
      this.isXScrolling = false;
      this.isYScrolling = false;
      this._lastTouchClientX = null;
      this._firstTouchClientX = null;
      this._firstTouchClientY = null;
    };

    BookstrapScroller.POSITION_LEFT = -1;
    BookstrapScroller.POSITION_CENTER = 0;
    BookstrapScroller.POSITION_RIGHT = 1;

    BookstrapScroller.prototype = new EventEmitter();

    BookstrapScroller.prototype.getScrollPosition = function() {
      return this._offset;
    };

    BookstrapScroller.prototype.getWidth = function() {
      return this._width;
    };

    BookstrapScroller.prototype.setWidth = function(width) {
      this._width = width;
      this._offset = this._width * this.domPage.position;
      this._startOffset = this._offset;
      this.snapToBoundary(0, { silent: true });
    };

    BookstrapScroller.prototype.getSnapPosition = function(movement) {
      if (movement === 0) {
        return this._startOffset;
      }
      return this._startOffset + (this._width * movement);
    };

    BookstrapScroller.prototype.getClientX = function(event) {
      return this.getClientCoord(event, 'clientX');
    };

    BookstrapScroller.prototype.getClientY = function(event) {
      return this.getClientCoord(event, 'clientY');
    };

    BookstrapScroller.prototype.getClientCoord = function(event, key) {
      var coord = event[key];
      if (coord === undefined) {
        if (event.touches) {
          coord = event.targetTouches[0][key];
        } else {
          console.error('Cannot find client co-ordinate');
          return;
        }
      }
      return coord;
    };

    BookstrapScroller.prototype.getScrollTouchId = function(event) {
      if (event.changedTouches)
        return event.changedTouches[0].identifier;
      return null;
    };

    BookstrapScroller.prototype.onMoveStart = function(event) {
      this._scrollTouchId = this.getScrollTouchId(event);
      this._hasMoveStarted = true;
      this._startOffset = this._offset;
      this._firstTouchClientX = this.getClientX(event);
      this._firstTouchClientY = this.getClientY(event);
    };

    BookstrapScroller.prototype.onMove = function(event) {
      if (this.getScrollTouchId(event) !== this._scrollTouchId)
        return;
      if (this.isYScrolling)
        return;
      if (! this._hasMoveStarted)
        return;

      var clientX = this.getClientX(event);
      if (this._lastTouchClientX === null) {
        this._lastTouchClientX = clientX;
      }
      if (this._firstTouchClientX === null) {
        this._firstTouchClientX = clientX;
      }
      movement = clientX - this._lastTouchClientX;
      this._lastTouchClientX = clientX;

      var xDistanceFromStart = this._firstTouchClientX - clientX,
          yDistanceFromStart = this._firstTouchClientY - this.getClientY(event);
      if (!this.isXScrolling && Math.abs(xDistanceFromStart) > this._scrollResponseBoundary) {
        this.isXScrolling = true;
      } else if (!this.isXScrolling && Math.abs(yDistanceFromStart) > this._scrollResponseBoundary) {
        this.isYScrolling = true;
        return;
      }
      if (! this.isXScrolling)
        return; // Let browser control scrolling

      // Take control of scrolling
      event.preventDefault();
      var swipeDirection = this.calculatePosition(this._offset + movement, this._startOffset);
      if (swipeDirection === BookstrapScroller.POSITION_RIGHT && !this.canMovePrevious)
        return;
      if (swipeDirection === BookstrapScroller.POSITION_LEFT && !this.canMoveNext)
        return;
      this.setScrollPosition(this._offset + movement);
    };

    BookstrapScroller.prototype.onMoveEnd = function(event) {
      if (this.getScrollTouchId(event) !== this._scrollTouchId) {
        this._scrollTouchId = null;
      }

      var wasYScrolling = this.isYScrolling;
      this._lastTouchClientX = null;
      this._hasMoveStarted = false;
      this.isXScrolling = false;
      this.isYScrolling = false;
      if (wasYScrolling) return;
      var distanceMoved = this._startOffset - this._offset;
      if (distanceMoved === 0) return;
      var swipeDirection = this.calculatePosition(0, distanceMoved);
      var positiveDistanceMoved = Math.abs(distanceMoved);
      if (positiveDistanceMoved < this._snapBoundary) {
        // stay on the same page
        swipeDirection = 0;
      }
      this.snapToBoundary(swipeDirection, { animate: true });
    };

    BookstrapScroller.prototype.setPosition = function(position, options) {
      var newOffset = this._width * position;
      this.domPage.position = position;
      this._startOffset = newOffset;
      if (this._offset !== newOffset) {
        this.setScrollPosition(newOffset, options);
      }
    };

    BookstrapScroller.prototype.updatePosition = function(options) {
      var newOffset = this._width * this.domPage.position;
      this._startOffset = newOffset;
      if (this._offset !== newOffset) {
        this.setScrollPosition(newOffset, options);
      }
    };

    BookstrapScroller.prototype.animateSnapToBoundary = function(swipeDirection, callback) {
      var targetOffset = this.getSnapPosition(this.domPage.position + swipeDirection);
      this.animation = {
        swipeDirection: swipeDirection,
        targetOffset: targetOffset,
        callback: callback,
        startOffset: this._offset,
        startTime: (new Date()).getTime(),
        totalDistance: targetOffset - this._offset,
        getOffset: swipeDirection > 0 ? Math.min : Math.max
      };
      this.emit('animationstart');
      requestAnimationFrame(_.bind(this.animate, this));
    };

    BookstrapScroller.prototype.animate = function() {
      var runningTime = (new Date()).getTime() - this.animation.startTime,
          percentComplete = runningTime / this._animationDuration,
          distanceMoved = this.animation.totalDistance * percentComplete,
          newPosition = this.animation.getOffset(this.animation.startOffset + distanceMoved, this.animation.targetOffset);

      this.setScrollPosition(newPosition);

      // Safety, we don't want the animation taking too long.
      var reachedTimeLimit = runningTime > MAX_ANIMATION_TIME;
      if (reachedTimeLimit || this._offset === this.animation.targetOffset) {
        console.log('animation complete after', runningTime);
        var callback = this.animation.callback;
        this.animation = null;
        if (callback) callback();
      } else {
        requestAnimationFrame(_.bind(this.animate, this));
      }
    };

    BookstrapScroller.prototype.snapToBoundary = function(swipeDirection, options) {
      options = options || { animate: false };
      if (options.animate) {
        var self = this;
        var onAnimationEnd = function() {
          self.setScrollPosition(self._width * (self.domPage.position + swipeDirection), { silent: true });
          self.emit('snap', swipeDirection);
        };
        this.animateSnapToBoundary(swipeDirection, onAnimationEnd);
      } else {
        this.setScrollPosition(this.getSnapPosition(swipeDirection), options);
        this.emit('snap', swipeDirection);
      }
    };

    BookstrapScroller.prototype.setScrollPosition = function(x, options) {
      options = options || {};
      var diff = this._offset - x;
      this._offset = x;
      this.domPage.$el.attr('style', '-webkit-transform: translate3d(' + this._offset + 'px, 0, 0); -moz-transform: translate3d(' + this._offset + 'px, 0, 0); transform: translate3d(' + this._offset + 'px, 0, 0)');
      var relativePosition = this.calculatePosition(this._offset, this._startOffset);
      if (! options.silent)
        this.emit('scroll', relativePosition, diff);
    };

    BookstrapScroller.prototype.calculatePosition = function(a, b) {
      var position;
      if (a > b) {
        position = BookstrapScroller.POSITION_RIGHT;
      } else if (a < b) {
        position = BookstrapScroller.POSITION_LEFT;
      } else {
        position = BookstrapScroller.POSITION_CENTER;
      }
      return position;
    };

    return BookstrapScroller;
});
