define([
  'underscore',
  'lib/events'
  ],
  function(_, EventEmitter) {

    var DOMPage = function(el, position) {
      this.page = undefined;
      this.pageLoaded = undefined;
      this.el = el;
      this.$el = $(el);
      this.position = position;
      this.isCached = false;
      this.hasEvents = false;
    };

    DOMPage.POSITION_LEFT = -1;
    DOMPage.POSITION_CENTER = 0;
    DOMPage.POSITION_RIGHT = 1;

    // Extract the body contents from the HTML
    // The browser will strip out the <body> if the HTML is appended to the document,
    // so use a regexp instead. Keep it simple by matching <body> and </body> invidually.
    DOMPage.extractBodyContents = function(html) {
      var openBodyTag = '<body>',
          closeBodyTag = '</body>',
          openOffset = html.search(new RegExp(openBodyTag, 'i')),
          closeOffset = html.search(new RegExp(closeBodyTag, 'i'));

      if (openOffset < 0 || closeOffset < 0) {
        throw new Error('Could not extract body contents.');
      }

      var contents = html.substring(0, closeOffset);
      return contents.substring(openOffset + openBodyTag.length);
    };

    DOMPage.prototype = _.extend({}, new EventEmitter(), {

      load: function(callback) {
        if (this.page !== this.pageLoaded) {
          this.isCached = false;
        }
        if (this.isCached) {
          if (callback) callback();
          return;
        }
        console.log('requesting', this.page.href);
        bookstrap.emit('beforepagecache', this);
        var self = this;
        require(['text!../' + this.page.href], function(html) {
          self.resetScrollPosition();
          self.$el.html(DOMPage.extractBodyContents(html));
          self.isCached = true;
          self.pageLoaded = self.page;
          bookstrap.emit('pagecache', self);
          if (callback) callback();
        });
      },

      isLeft: function() {
        return this.position === DOMPage.POSITION_LEFT;
      },

      isRight: function() {
        return this.position === DOMPage.POSITION_RIGHT;
      },

      updatePosition: function(position) {
        if (position)
          this.position = position;
        var offset = bookstrap.viewport.width * this.position;
        $(this.el).attr('style', '-webkit-transform: translate3d(' + offset + 'px, 0, 0); -moz-transform: translate3d(' + offset + 'px, 0, 0); transform: translate3d(' + offset + 'px, 0, 0)');
      },

      resetScrollPosition: function () {
        this.el.scrollTop = 0;
      },

      isCacheReady: function() {
        return (!this.page) || this.isCached;
      },

      bindEvents: function() {
        if (this.hasEvents) return;
        this.hasEvents = true;
      },

      destroy: function() {
        this.$el.remove();
        bookstrap.emit('pagedestroyed', this);
      }

    });
    return DOMPage;
  }
);